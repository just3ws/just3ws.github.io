<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  











<title>Interview Archive — Ola Bini at GOTO Conference 2013 (GOTO Conference)</title>
<meta name="description" content="Interview with Ola Bini at GOTO Conference 2013. Topic: conference speaking and presentation skills. Conference: GOTO Conference 2013. Recorded: 2022-05-13.…">
<meta name="author" content="Mike Hall">
<link rel="canonical" href="https://www.just3ws.com/interviews/ola-bini-general/">

<meta name="release-timestamp" content="2026-02-16 17:40:57 +0000">

<meta name="robots" content="index,follow">
<meta property="og:title" content="Interview Archive — Ola Bini at GOTO Conference 2013 (GOTO Conference)">
<meta property="og:description" content="Interview with Ola Bini at GOTO Conference 2013. Topic: conference speaking and presentation skills. Conference: GOTO Conference 2013. Recorded: 2022-05-13.…">
<meta property="og:url" content="https://www.just3ws.com/interviews/ola-bini-general/">
<meta property="og:type" content="website">
<meta property="og:site_name" content="Mike Hall">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Interview Archive — Ola Bini at GOTO Conference 2013 (GOTO Conference)">
<meta name="twitter:description" content="Interview with Ola Bini at GOTO Conference 2013. Topic: conference speaking and presentation skills. Conference: GOTO Conference 2013. Recorded: 2022-05-13.…">
<link rel="shortcut icon" href="/favicon.ico">


<link rel="stylesheet" href="/assets/css/core.css">
<link rel="stylesheet" href="/assets/css/themes/site.css">
<link rel="stylesheet" href="/assets/css/digital-patina.css">



  <script data-goatcounter="https://just3ws.goatcounter.com/count"
      async src="https://gc.zgo.at/count.js"></script>
<script src="/assets/js/goatcounter-events.js" defer></script>

  
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "WebSite",
  "url": "http://localhost:4000/",
  "potentialAction": {
    "@type": "SearchAction",
    "target": {
      "@type": "EntryPoint",
      "urlTemplate": "http://localhost:4000/search/?q={search_term_string}"
    },
    "query-input": "required name=search_term_string"
  }
}
</script>

  
</head>
<body>
  <a href="#main-content" class="skip-link">Skip to main content</a>
  <header class="site-header no-print" role="banner">
  <nav class="site-nav" aria-label="Primary">
    
    
    
    
    <a
      class="site-nav-brand"
      href="/home/"
      
    >
      <img class="site-nav-avatar" src="/avatar.png" alt="Mike Hall">
      Mike Hall
    </a>
    <div class="site-nav-links">
      
        
        
        
        
        
        <a href="/" >Resume</a>
      
        
        
        
        
        
        <a href="/writing/" >Writing</a>
      
        
        
        
        
        
        <a href="/interviews/" class="is-active" aria-current="page">Interviews</a>
      
        
        
        
        
        
        <a href="/contact/" >Contact</a>
      
    </div>
  </nav>
</header>

  <main id="main-content">
    <article class="page">
  <nav class="breadcrumbs" aria-label="Breadcrumb">
  
  
  
  

  
    <a href="/home/">Home</a>
    <span class="breadcrumbs-separator">/</span>

    

    
      
        <a href="/interviews/">Interviews</a>
        <span class="breadcrumbs-separator">/</span>
      
    

    
      <a href="/interviews/ola-bini-general/">Interview with Ola Bini at GOTO Conference 2013</a>
    
  
</nav>






<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    
      {
        "@type": "ListItem",
        "position": 1,
        "name": "Home",
        "item": "https://www.just3ws.com/home/"
      }
      
      ,
      {
        "@type": "ListItem",
        "position": 2,
        "name": "Interviews",
        "item": "https://www.just3ws.com/interviews/"
      },
      {
        "@type": "ListItem",
        "position": 3,
        "name": "Interview with Ola Bini at GOTO Conference 2013",
        "item": "https://www.just3ws.com/interviews/ola-bini-general/"
      }
    
  ]
}
</script>


  
  
    
    <header>
      <h1>Interview with Ola Bini at GOTO Conference 2013</h1>
    </header>
    
      <div class="video-subtitle">Interviewee: <a href="/interviews/people/ola-bini/">Ola Bini</a> (<a href="https://gotocon.com/chicago-2013/speaker/Ola+Bini">conference bio</a>)</div>
    
    
      <div class="video-subtitle">Topic: conference speaking and presentation skills</div>
    
    <div class="video-meta">
      
        Conference:
        
        
        
          <a href="/interviews/conferences/goto-2013/">GOTO Conference 2013</a>
        
      
      
    </div>

    
    

    
    


















<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "CreativeWork",
  "additionalType": "https://schema.org/Interview",
  "@id": "https://www.just3ws.com/id/interview/ola-bini-general",
  "identifier": "ola-bini-general",
  "name": "Interview with Ola Bini at GOTO Conference 2013",
  "url": "https://www.just3ws.com/interviews/ola-bini-general/",
  "datePublished": "2022-05-13",
  "description": "Interview with Ola Bini at GOTO Conference 2013. Topic: conference speaking and presentation skills. Conference: GOTO Conference 2013. Recorded: 2022-05-13.…",
  "inLanguage": "en",
  "author": {
    "@type": "Person",
    "@id": "https://www.just3ws.com/id/person/mike-hall",
    "name": "Mike Hall"
  },
  
  "contributor": [
    
    {
      "@type": "Person",
      "@id": "https://www.just3ws.com/id/person/ola-bini",
      "name": "Ola Bini"
    }
    
  ],
  
  
  
  "about": [
    {
      "@type": "Thing",
      "name": "conference speaking and presentation skills"
    }
    
  
  
    ,
    {
      "@type": "Event",
      "@id": "https://www.just3ws.com/id/conference/goto-conference-2013",
      "name": "GOTO Conference 2013"
    }
  ],
  
  
  "subjectOf": {
    "@type": "VideoObject",
    "@id": "https://www.just3ws.com/id/video/ola-bini-general",
    "name": "Interview with Ola Bini",
    "description": "Interview with Ola Bini at GOTO Conference 2013 on conference speaking and presentation skills. This recording captures practical lessons and perspective for software teams and technical communities.",
    "thumbnailUrl": "https://i.ytimg.com/vi/51nQ3OVFFCU/hqdefault.jpg",
    "uploadDate": "2022-05-13",
    "transcript": "Hi, it's Mike again with Uteastic. I'm still here today at\n the GOTO Conf Chicago 2013. Right now I'm\n sitting down with Ola Beeney. Ola has been kind of a prol\nific committer to open source and most,\n probably I'm assuming most dear to your heart is your own\n language, Aoki. Well, first thank you for\n sitting down with me to talk and what is Aoki and why did\n you create it? So, Aoki is a programming\n language. It's an experiment first and foremost. I decided\n to create it because I was at the point\n in my language interest because I've been part of the JRuby\n project for many years and before\n that I was part of another language implementation on the J\nVM and for a long time I've been kind of\n searching for the right language on the right platform.\n And JRuby was a good step in the right direction, but Ruby\n as a language still didn't have everything\n I wanted a language to have and I wasn't really sure. I was\n looking around, I was learning a lot\n of languages, teaching myself most of the languages out\n there to some degree or another and trying to\n find something that suited me and at some point I just gave\n up and decided to, okay, I'm just going\n to try creating something myself and see where that ends up\n. Just explicitly experimenting, making it\n a laboratory for free.\n So, I'm just going to try creating something for free\n instead of something that is supposed to be useful.\n So, I went in with it expecting it to be slow, expecting it\n to not necessarily have all the\n features that a general purpose language really has to have\n. And it's played out really well.\n I've had a maximum of 10 users. People are poking on it,\n testing it and doing fun stuff with it,\n but it's more of an inspiration to people more than\n anything else. And I've done a lot of crazy\n stuff that I quite like in it. It is a dog slow. It's not\n useful for real purpose things. I think\n at this point, it was probably six or seven years ago since\n I started creating it. But that was kind of\n where it started out. So, it is a language that is based on\n the JVM. That was on purpose because I wanted\n to bootstrap based on all the existing stuff that was\n available on the platform, the GC, the libraries,\n all that stuff that makes it so much easier to do stuff\n without having to build it all from scratch.\n I started with a design that is very similar to a language\n called I/O.\n It's a small embedded language that runs in C. It's written\n in C. I/O has a very different standard library.\n And the core library and the core implementations are quite\n different. Fundamentally, at the lowest level,\n I/O can do very similar things, but everything on top of\n the core message sending routines are quite\n different. And specifically, I/O has a lot of inspiration\n from Lisp.\n When it comes to thinking around macros, and also uses a\n lot of small talk thinking when it comes to first or higher\n order\n concepts, having first class versions of everything in the\n system and so on.\n Well, with the expressiveness of, because I read a little\n bit about the Wikipedia page.\n I haven't tried I/O yet, but what I understand is that\n where Lisp had to make certain trade-offs,\n to become performance and usable, you're not making those\n trade-offs in favor of strict adherence to what your design\n principles are.\n But I have to wonder, is there certain problems that you\n could solve with I/O key that, while they might not be fast\n,\n maybe can be more, is there something that you can do with\n I/O key that you could easily do with another language,\n even Lisp?\n Yeah, I mean, I think that modeling some kinds of things\n are actually really powerful in I/O key.\n So, let me just talk quickly about, so the basic language\n features that makes I/O key different from a Lisp is really\n that it is a prototype-based object-oriented language at\n the core of the language.\n And that is really visible all through the whole thing.\n It embraces mutability at every level, so everything in the\n system is available at runtime in the system.\n A small example, and this is something that makes it very\n easy to do domain-specific languages in I/O key, is that\n you actually have access to the parsing tables,\n so you can modify the parsing tables at runtime.\n Fundamentally, I/O key syntax is a very simple prefix\n engine, but it does something that I call operator shuff\nling,\n where you really fundamentally can change the precedence of\n different operators.\n You can add new operators, you can strip away and have no\n operator whatsoever.\n But at the end of the day, they will all compile down, they\n will all parse and shuffle down into a canonical AST.\n And that canonical AST at runtime is available also at\n runtime.\n In fact, every time you call a method, that is represented\n as a first-class message that you have access to if you\n want to.\n And if you call a method, that method can have access to\n the outside context of where it's called at runtime,\n which means that, in fact, since the AST is mutable at\n runtime, you can have methods that can reach back into the\n point where they were called.\n You can modify the code at that point if you want to.\n So you can have macros that have effects outside of the\n inside of the macro if you want to, for example.\n I'm going to have to go back and re-watch this for you a\n couple of times.\n The reason I was starting to laugh is because, obviously,\n you're somebody who's extremely comfortable with dealing\n with multiple languages\n and have really delved into how languages even work.\n You talked about that you use about seven to eight\n languages in the cancer research problem.\n I just want to go back to a young Ola who was in school.\n How did you get involved?\n Where did the language bug bite you?\n That's a very hard question.\n So I started programming when I was seven years old.\n That was basic on an Apple IIc.\n I started writing small games and stuff like that at that\n point.\n And then I very quickly went through C, C++, and Assembler.\n So in Scandinavia, there was something called the demo\n scene that grew out of the games pirating.\n I don't know if you remember, in the '80s and '90s where\n you got a pirated game,\n you usually had an intro to the game where the pirating\n group, they kind of did a presentation showing how cool and\n elite they were.\n And then the real game started.\n And then when the game rose, they kind of cropped off and\n took off separately from the pirating movement and became\n kind of a scene by itself\n where people were trying to impress each other, come up\n with really impressive graphical things that did--\n I mean, it's almost like small movies doing programming.\n And I was deeply involved in that movement.\n There were things like doing the coolest presentation you\n can do in 64 kilobytes of space, for example.\n And then I got into programming.\n And in order to learn--I mean, you have to use C or C++ for\n the top-level stuff.\n You had to use Assembler for the graphic routines.\n You had to be able to understand Pascal as well because\n half of the tutorials and stuff like that was in Pascal and\n half of it was in C.\n So in order to learn all the techniques, you had to switch\n back and forth.\n All the 3D engines were written in C++, so you had to get\n into that.\n And at some point, I don't know, I became very used to\n switching between the two.\n And then I branched out, I found Lisp, and then I--yeah, it\n just branched out.\n And then I did Java for a few years in a corporate setting\n--or actually not a corporate, in a university setting.\n But I worked for the IT department and did Java development\n for them.\n And I realized that I was very unhappy with the\n capabilities of these languages, so I started branching out\n.\n This was probably when I was 19, 20.\n I started learning more and more languages just to find\n something better because I was so dissatisfied with the--\n with the capabilities of the existing languages, with the\n way the code grow like crazy, with the limited abstraction\n capabilities and so on.\n So because you were exposed to so many languages at a young\n age and the hard internals.\n I suspect so, yeah, because the other thing that I--I have\n a strong belief in the power of programming languages to\n help us manage complex problems.\n I think that's really important.\n But I also believe that the best programmers out there are\n the ones who understand the whole machine.\n The whole stack has a full system-level understanding so\n that when you use a really high-level feature, you know\n what the cost is.\n And you know when to use it and when not to use it.\n You know when you can just ignore it completely and just\n focus on the high-level stuff.\n And you know when you actually have to think about it.\n So do you think that maybe there's a--I just have to wonder\n now, since so much of our languages are really high-abst\nraction languages, they really hide a lot of all of that\n internals.\n Do you think that maybe there's a--\n Is there a negative trend as kids are learning those really\n high-abstraction languages and they're not seeing so many\n internals?\n Is there maybe a danger in that?\n Well, I mean, okay, so let me first make one point, and\n that is I don't actually believe that our languages are\n that high-level right now.\n I mean, a language like Java, for example, is very low-\nlevel.\n And that still was used for most of the--C# and Java are\n really like still the major programming languages.\n And they are not high-level.\n In fact, one of the problems with them is that\n they don't hide enough of the machine.\n They're this kind of weird mix of trying to be high-level\n in one area and then showing their paddings in the other\n one.\n I think it's more of what I was--not so much that I'm\n dealing with registers and interrupts and things like that,\n but that dealing with really moving memory from here to\n here and then jumping in, making it really low-level and\n having to think in this very concrete,\n low-level--like with Java, I'm just going to say I'm going\n to call a collection and I'm going to iterate over it.\n And I'm not thinking about what that iteration is really\n doing, that it's moving--\n And incidentally, I mean, that whole approach in Java 8 is\n going to change because then you have to stop thinking\n about it as iterating\n because iterating is actually--it's too tied to the\n implementation pattern.\n And maybe iterating, like actually going from the next\n pointer, is going to be the wrong approach when you're\n using lambdas and streams in Java 8 instead.\n I think, going back to your original question, I think that\n the main problem is not so much that our high-level\n languages are hiding this stuff.\n I think that the way we are teaching new programmers how to\n deal with things at different levels should change.\n I think that we are de-emphasizing things too much.\n I actually believe it's good that people learn a lot of\n different languages, but that we then have the choice to\n use the language at the right abstraction level for what we\n need to do.\n I think that we are missing--we have all this low-level\n stuff and then up to a specific point, but then we are\n actually missing this really, really high-level stuff that\n will allow us to manage much more of the complexity than\n what we're doing today.\n And I think that a lot of today's focus on functional\n programming is actually misdirected.\n It's misdirected unhappiness with the fact that we don't\n have other high-level mechanisms right now.\n It makes me kind of think about Dan North's talk about dog\nma.\n Before we had--you can't have procedural programming, you\n have to have object-oriented, and now everybody's dogmatic\n about doing object.\n Now it's--the new dogma is, well, if you're not doing\n functional, you're not cool, but, you know--\n That's true.\n It's--\n And it's kind of funny, coming off a project where I've\n used the functional language for the last year as the main\n language, it's like I'm still not a functional--I mean, I\n don't think functional is going to solve anything.\n I think functional is a useful tool, just like all the\n other tools, but the reason we use Clojure was not because\n it's functional.\n It's because it's a LISP.\n Right.\n And those two things are not actually the same thing.\n You can use a LISP for macros and data structure, for\n example, without really caring about the fact that it's\n functional, and the other way around.\n Okay.\n And is you--I'm going to just jump over to the JRuby\n project.\n Mm-hmm.\n Now, the Clojure--now I'm struggling for the question I\n want to ask, but it's on the tip of my tongue, but you've\n worked on LISP.\n And you've worked--you know, I'm really understanding how\n the JVM works.\n How did you get involved with working on the--with JRuby?\n Because it seems like Ruby and the LISP community seem to\n have a very different approach to designing software.\n You know, you're obviously comfortable in moving between\n multiple languages, but when you look at the two, the Cloj\nure community and the JRuby community, what really\n differences do you see there?\n And not just--\n Not just the languages themselves, but the users and the\n community around them.\n Hmm.\n That's an interesting question.\n I mean, I think--I think there is a lot of things in common\n, especially if you take away just the JRuby community, not\n just--not the whole Ruby community, but the JRuby community\n.\n I actually think that there are more things in common\n between the JRuby and Clojure community than anything else.\n And, I mean, you can see that many of the companies and\n people that were big on using JRuby and Ruby, like,\n relatively recently, they're not.\n Yeah.\n They're not.\n They're not using it.\n They're using it for other things.\n They're not using it for other things.\n They're not using it for other things.\n They're using it for other things.\n They're not using it for other things.\n They're using it for other things.\n They're using it for other things.\n They're using it for other things.\n They're using it for other things.\n They're using it for other things.\n They're using it for other things.\n But they're not giving up on JRuby.\n They're just using it for some parts of the system.\n I think what I'm seeing--the most thing that I see in\n common is actually that these--the people who are doing\n this are the people who are pragmatic.\n They're using it for real-world, complicated systems where\n they actually need the benefit of something like Clojure\n for leverage, but running on the JVM is a pragmatic choice\n and using JRuby for other parts where--I mean, JRuby still\n has a lot of benefits when it comes to libraries, I would\n say, because, like, or even frameworks, like Rails is a\n good example.\n Actually, I don't use Rails that much anymore, but you\n still have lightweight libraries like Sinatra.\n You still have really lightweight libraries.\n You still have really lightweight libraries.\n You still have really lightweight libraries.\n You still have really lightweight libraries.\n You still have really lightweight libraries.\n You still have really lightweight libraries.\n You still have really lightweight libraries.\n And you're using the right tool for the job.\n I mean, that seems to be what unifies the JRuby and the Clo\njure people to a large degree.\n And you're using the right tool for the job.\n I mean, that seems to be what unifies the JRuby and the Clo\njure people to a large degree.\n I mean, that seems to be what unifies the JRuby and the Clo\njure people to a large degree.\n Okay.\n Well, thank you very much for taking the time to stand here\n.\n I really appreciate it.\n Thank you.\n Thanks.\n And just a last kind of final wrap-up question is, if\n somebody is looking at, interested\n in digging into EOKI and trying to understand it and using\n it to better understand languages,\n where should they start?\n Well, you can definitely start with the guide.\n It's a fairly complete guide.\n The source code is not that large, and a lot of it is\n actually written in EOKI itself.\n I think one of the more interesting aspects of EOKI was\n that...\n I wrote the whole thing TDD.\n So there is a complete test code base that covers the whole\n language.\n So when I created the .NET version of EOKI, I just let the\n tests actually guide the whole\n implementation.\n So it was very easy to make a port of it to C# and F#.\n So looking at the tests, looking at the internal\n implementation is actually...\n I mean, it's not a big project by itself.\n So I think that should be easy, since I don't do a lot of\n fancy stuff in order to make a\n really fast.\n The code is not as impenetrable as some other language\n implementations can be.\n Like, JRuby has fantastic source code.\n It's beautifully written, but it is written with more than\n an I2 performance, and that\n sometimes you have to read a lot to understand the things\n that make it necessary to do things\n a specific way, for example.\n Okay.\n So is there a website, EOKI?\n Yeah, EOKI.org.\n EOKI.org?\n Yeah.\n Okay.\n So go check out EOKI.org and try to expand your...\n your language horizons.\n Thanks again.\n Thank you.\n Okay, great.\n Thank you very much.\n I really appreciate it.\n Yeah.",
    "url": "https://www.just3ws.com/videos/ola-bini-general/",
    "embedUrl": "https://www.youtube.com/embed/51nQ3OVFFCU"
  },
  
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://www.just3ws.com/interviews/ola-bini-general/"
  }
}
</script>

    

  
  
  
  
  
  
  

  
    <div class="video video-detail has-transcript">
      
        <div class="video-embed">
          <iframe id="interview-embed" src="https://www.youtube.com/embed/51nQ3OVFFCU" width="640" height="360" frameborder="0" allow="autoplay; fullscreen; picture-in-picture; clipboard-write; encrypted-media; web-share" referrerpolicy="strict-origin-when-cross-origin" title="Interview with Ola Bini"></iframe>
        </div>
      
      <div class="video-body">
        
          <div class="video-indicators">
            <span class="video-indicator transcript" aria-label="Transcript available">★ Transcript Available</span>
            <a class="video-indicator-link" href="#transcript">Jump to transcript</a>
          </div>
        
        
          <div class="video-description"><span class="video-description-label">Description:</span> Interview with Ola Bini at GOTO Conference 2013 on conference speaking and presentation skills. This recording captures practical lessons and perspective for software teams and technical communities.</div>
        
        <div class="video-meta">
          Published: May 13, 2022
        </div>
        <div class="video-actions">
          
            <button class="video-button primary" data-embed="https://www.youtube.com/embed/51nQ3OVFFCU">Watch Here (Youtube)</button>
          
        </div>
        <div class="video-actions">
          
            <a class="video-button" href="https://www.youtube.com/watch?v=51nQ3OVFFCU&list=PLgmTADxYKzzYKdyO4oJ04tY28LITr9MLm">Watch on Youtube</a>
          
        </div>
      </div>
    </div>
  

  <section class="transcript" id="transcript">
    <h2>Transcript</h2>
    
      <div class="video-transcript"><p>Hi, it’s Mike again with Uteastic. I’m still here today at
 the GOTO Conf Chicago 2013. Right now I’m
 sitting down with Ola Beeney. Ola has been kind of a prol
ific committer to open source and most,
 probably I’m assuming most dear to your heart is your own
 language, Aoki. Well, first thank you for
 sitting down with me to talk and what is Aoki and why did
 you create it? So, Aoki is a programming
 language. It’s an experiment first and foremost. I decided
 to create it because I was at the point
 in my language interest because I’ve been part of the JRuby
 project for many years and before
 that I was part of another language implementation on the J
VM and for a long time I’ve been kind of
 searching for the right language on the right platform.
 And JRuby was a good step in the right direction, but Ruby
 as a language still didn’t have everything
 I wanted a language to have and I wasn’t really sure. I was
 looking around, I was learning a lot
 of languages, teaching myself most of the languages out
 there to some degree or another and trying to
 find something that suited me and at some point I just gave
 up and decided to, okay, I’m just going
 to try creating something myself and see where that ends up
. Just explicitly experimenting, making it
 a laboratory for free.
 So, I’m just going to try creating something for free
 instead of something that is supposed to be useful.
 So, I went in with it expecting it to be slow, expecting it
 to not necessarily have all the
 features that a general purpose language really has to have
. And it’s played out really well.
 I’ve had a maximum of 10 users. People are poking on it,
 testing it and doing fun stuff with it,
 but it’s more of an inspiration to people more than
 anything else. And I’ve done a lot of crazy
 stuff that I quite like in it. It is a dog slow. It’s not
 useful for real purpose things. I think
 at this point, it was probably six or seven years ago since
 I started creating it. But that was kind of
 where it started out. So, it is a language that is based on
 the JVM. That was on purpose because I wanted
 to bootstrap based on all the existing stuff that was
 available on the platform, the GC, the libraries,
 all that stuff that makes it so much easier to do stuff
 without having to build it all from scratch.
 I started with a design that is very similar to a language
 called I/O.
 It’s a small embedded language that runs in C. It’s written
 in C. I/O has a very different standard library.
 And the core library and the core implementations are quite
 different. Fundamentally, at the lowest level,
 I/O can do very similar things, but everything on top of
 the core message sending routines are quite
 different. And specifically, I/O has a lot of inspiration
 from Lisp.
 When it comes to thinking around macros, and also uses a
 lot of small talk thinking when it comes to first or higher
 order
 concepts, having first class versions of everything in the
 system and so on.
 Well, with the expressiveness of, because I read a little
 bit about the Wikipedia page.
 I haven’t tried I/O yet, but what I understand is that
 where Lisp had to make certain trade-offs,
 to become performance and usable, you’re not making those
 trade-offs in favor of strict adherence to what your design
 principles are.
 But I have to wonder, is there certain problems that you
 could solve with I/O key that, while they might not be fast
,
 maybe can be more, is there something that you can do with
 I/O key that you could easily do with another language,
 even Lisp?
 Yeah, I mean, I think that modeling some kinds of things
 are actually really powerful in I/O key.
 So, let me just talk quickly about, so the basic language
 features that makes I/O key different from a Lisp is really
 that it is a prototype-based object-oriented language at
 the core of the language.
 And that is really visible all through the whole thing.
 It embraces mutability at every level, so everything in the
 system is available at runtime in the system.
 A small example, and this is something that makes it very
 easy to do domain-specific languages in I/O key, is that
 you actually have access to the parsing tables,
 so you can modify the parsing tables at runtime.
 Fundamentally, I/O key syntax is a very simple prefix
 engine, but it does something that I call operator shuff
ling,
 where you really fundamentally can change the precedence of
 different operators.
 You can add new operators, you can strip away and have no
 operator whatsoever.
 But at the end of the day, they will all compile down, they
 will all parse and shuffle down into a canonical AST.
 And that canonical AST at runtime is available also at
 runtime.
 In fact, every time you call a method, that is represented
 as a first-class message that you have access to if you
 want to.
 And if you call a method, that method can have access to
 the outside context of where it’s called at runtime,
 which means that, in fact, since the AST is mutable at
 runtime, you can have methods that can reach back into the
 point where they were called.
 You can modify the code at that point if you want to.
 So you can have macros that have effects outside of the
 inside of the macro if you want to, for example.
 I’m going to have to go back and re-watch this for you a
 couple of times.
 The reason I was starting to laugh is because, obviously,
 you’re somebody who’s extremely comfortable with dealing
 with multiple languages
 and have really delved into how languages even work.
 You talked about that you use about seven to eight
 languages in the cancer research problem.
 I just want to go back to a young Ola who was in school.
 How did you get involved?
 Where did the language bug bite you?
 That’s a very hard question.
 So I started programming when I was seven years old.
 That was basic on an Apple IIc.
 I started writing small games and stuff like that at that
 point.
 And then I very quickly went through C, C++, and Assembler.
 So in Scandinavia, there was something called the demo
 scene that grew out of the games pirating.
 I don’t know if you remember, in the ’80s and ’90s where
 you got a pirated game,
 you usually had an intro to the game where the pirating
 group, they kind of did a presentation showing how cool and
 elite they were.
 And then the real game started.
 And then when the game rose, they kind of cropped off and
 took off separately from the pirating movement and became
 kind of a scene by itself
 where people were trying to impress each other, come up
 with really impressive graphical things that did–
 I mean, it’s almost like small movies doing programming.
 And I was deeply involved in that movement.
 There were things like doing the coolest presentation you
 can do in 64 kilobytes of space, for example.
 And then I got into programming.
 And in order to learn–I mean, you have to use C or C++ for
 the top-level stuff.
 You had to use Assembler for the graphic routines.
 You had to be able to understand Pascal as well because
 half of the tutorials and stuff like that was in Pascal and
 half of it was in C.
 So in order to learn all the techniques, you had to switch
 back and forth.
 All the 3D engines were written in C++, so you had to get
 into that.
 And at some point, I don’t know, I became very used to
 switching between the two.
 And then I branched out, I found Lisp, and then I–yeah, it
 just branched out.
 And then I did Java for a few years in a corporate setting
–or actually not a corporate, in a university setting.
 But I worked for the IT department and did Java development
 for them.
 And I realized that I was very unhappy with the
 capabilities of these languages, so I started branching out
.
 This was probably when I was 19, 20.
 I started learning more and more languages just to find
 something better because I was so dissatisfied with the–
 with the capabilities of the existing languages, with the
 way the code grow like crazy, with the limited abstraction
 capabilities and so on.
 So because you were exposed to so many languages at a young
 age and the hard internals.
 I suspect so, yeah, because the other thing that I–I have
 a strong belief in the power of programming languages to
 help us manage complex problems.
 I think that’s really important.
 But I also believe that the best programmers out there are
 the ones who understand the whole machine.
 The whole stack has a full system-level understanding so
 that when you use a really high-level feature, you know
 what the cost is.
 And you know when to use it and when not to use it.
 You know when you can just ignore it completely and just
 focus on the high-level stuff.
 And you know when you actually have to think about it.
 So do you think that maybe there’s a–I just have to wonder
 now, since so much of our languages are really high-abst
raction languages, they really hide a lot of all of that
 internals.
 Do you think that maybe there’s a–
 Is there a negative trend as kids are learning those really
 high-abstraction languages and they’re not seeing so many
 internals?
 Is there maybe a danger in that?
 Well, I mean, okay, so let me first make one point, and
 that is I don’t actually believe that our languages are
 that high-level right now.
 I mean, a language like Java, for example, is very low-
level.
 And that still was used for most of the–C# and Java are
 really like still the major programming languages.
 And they are not high-level.
 In fact, one of the problems with them is that
 they don’t hide enough of the machine.
 They’re this kind of weird mix of trying to be high-level
 in one area and then showing their paddings in the other
 one.
 I think it’s more of what I was–not so much that I’m
 dealing with registers and interrupts and things like that,
 but that dealing with really moving memory from here to
 here and then jumping in, making it really low-level and
 having to think in this very concrete,
 low-level–like with Java, I’m just going to say I’m going
 to call a collection and I’m going to iterate over it.
 And I’m not thinking about what that iteration is really
 doing, that it’s moving–
 And incidentally, I mean, that whole approach in Java 8 is
 going to change because then you have to stop thinking
 about it as iterating
 because iterating is actually–it’s too tied to the
 implementation pattern.
 And maybe iterating, like actually going from the next
 pointer, is going to be the wrong approach when you’re
 using lambdas and streams in Java 8 instead.
 I think, going back to your original question, I think that
 the main problem is not so much that our high-level
 languages are hiding this stuff.
 I think that the way we are teaching new programmers how to
 deal with things at different levels should change.
 I think that we are de-emphasizing things too much.
 I actually believe it’s good that people learn a lot of
 different languages, but that we then have the choice to
 use the language at the right abstraction level for what we
 need to do.
 I think that we are missing–we have all this low-level
 stuff and then up to a specific point, but then we are
 actually missing this really, really high-level stuff that
 will allow us to manage much more of the complexity than
 what we’re doing today.
 And I think that a lot of today’s focus on functional
 programming is actually misdirected.
 It’s misdirected unhappiness with the fact that we don’t
 have other high-level mechanisms right now.
 It makes me kind of think about Dan North’s talk about dog
ma.
 Before we had–you can’t have procedural programming, you
 have to have object-oriented, and now everybody’s dogmatic
 about doing object.
 Now it’s–the new dogma is, well, if you’re not doing
 functional, you’re not cool, but, you know–
 That’s true.
 It’s–
 And it’s kind of funny, coming off a project where I’ve
 used the functional language for the last year as the main
 language, it’s like I’m still not a functional–I mean, I
 don’t think functional is going to solve anything.
 I think functional is a useful tool, just like all the
 other tools, but the reason we use Clojure was not because
 it’s functional.
 It’s because it’s a LISP.
 Right.
 And those two things are not actually the same thing.
 You can use a LISP for macros and data structure, for
 example, without really caring about the fact that it’s
 functional, and the other way around.
 Okay.
 And is you–I’m going to just jump over to the JRuby
 project.
 Mm-hmm.
 Now, the Clojure–now I’m struggling for the question I
 want to ask, but it’s on the tip of my tongue, but you’ve
 worked on LISP.
 And you’ve worked–you know, I’m really understanding how
 the JVM works.
 How did you get involved with working on the–with JRuby?
 Because it seems like Ruby and the LISP community seem to
 have a very different approach to designing software.
 You know, you’re obviously comfortable in moving between
 multiple languages, but when you look at the two, the Cloj
ure community and the JRuby community, what really
 differences do you see there?
 And not just–
 Not just the languages themselves, but the users and the
 community around them.
 Hmm.
 That’s an interesting question.
 I mean, I think–I think there is a lot of things in common
, especially if you take away just the JRuby community, not
 just–not the whole Ruby community, but the JRuby community
.
 I actually think that there are more things in common
 between the JRuby and Clojure community than anything else.
 And, I mean, you can see that many of the companies and
 people that were big on using JRuby and Ruby, like,
 relatively recently, they’re not.
 Yeah.
 They’re not.
 They’re not using it.
 They’re using it for other things.
 They’re not using it for other things.
 They’re not using it for other things.
 They’re using it for other things.
 They’re not using it for other things.
 They’re using it for other things.
 They’re using it for other things.
 They’re using it for other things.
 They’re using it for other things.
 They’re using it for other things.
 They’re using it for other things.
 But they’re not giving up on JRuby.
 They’re just using it for some parts of the system.
 I think what I’m seeing–the most thing that I see in
 common is actually that these–the people who are doing
 this are the people who are pragmatic.
 They’re using it for real-world, complicated systems where
 they actually need the benefit of something like Clojure
 for leverage, but running on the JVM is a pragmatic choice
 and using JRuby for other parts where–I mean, JRuby still
 has a lot of benefits when it comes to libraries, I would
 say, because, like, or even frameworks, like Rails is a
 good example.
 Actually, I don’t use Rails that much anymore, but you
 still have lightweight libraries like Sinatra.
 You still have really lightweight libraries.
 You still have really lightweight libraries.
 You still have really lightweight libraries.
 You still have really lightweight libraries.
 You still have really lightweight libraries.
 You still have really lightweight libraries.
 You still have really lightweight libraries.
 And you’re using the right tool for the job.
 I mean, that seems to be what unifies the JRuby and the Clo
jure people to a large degree.
 And you’re using the right tool for the job.
 I mean, that seems to be what unifies the JRuby and the Clo
jure people to a large degree.
 I mean, that seems to be what unifies the JRuby and the Clo
jure people to a large degree.
 Okay.
 Well, thank you very much for taking the time to stand here
.
 I really appreciate it.
 Thank you.
 Thanks.
 And just a last kind of final wrap-up question is, if
 somebody is looking at, interested
 in digging into EOKI and trying to understand it and using
 it to better understand languages,
 where should they start?
 Well, you can definitely start with the guide.
 It’s a fairly complete guide.
 The source code is not that large, and a lot of it is
 actually written in EOKI itself.
 I think one of the more interesting aspects of EOKI was
 that…
 I wrote the whole thing TDD.
 So there is a complete test code base that covers the whole
 language.
 So when I created the .NET version of EOKI, I just let the
 tests actually guide the whole
 implementation.
 So it was very easy to make a port of it to C# and F#.
 So looking at the tests, looking at the internal
 implementation is actually…
 I mean, it’s not a big project by itself.
 So I think that should be easy, since I don’t do a lot of
 fancy stuff in order to make a
 really fast.
 The code is not as impenetrable as some other language
 implementations can be.
 Like, JRuby has fantastic source code.
 It’s beautifully written, but it is written with more than
 an I2 performance, and that
 sometimes you have to read a lot to understand the things
 that make it necessary to do things
 a specific way, for example.
 Okay.
 So is there a website, EOKI?
 Yeah, EOKI.org.
 EOKI.org?
 Yeah.
 Okay.
 So go check out EOKI.org and try to expand your…
 your language horizons.
 Thanks again.
 Thank you.
 Okay, great.
 Thank you very much.
 I really appreciate it.
 Yeah.</p>
</div>
    
  </section>

  <script>
    (function() {
      var embed = document.getElementById("interview-embed");
      if (!embed) return;
      var buttons = document.querySelectorAll("[data-embed]");
      buttons.forEach(function(btn) {
        btn.addEventListener("click", function() {
          embed.setAttribute("src", btn.getAttribute("data-embed"));
        });
      });
    })();
  </script>


  
</article>

  </main>
</body>
</html>
