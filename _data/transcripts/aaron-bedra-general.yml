---
content: |-
  Hi, I'm Mike.
  I'm here with Aaron Bedra.
  Aaron has contributed to the Clojure language.
  He's also spoken extensively on Clojure and functional programming and all kinds of other neat stuff here at GeekFest and a few conferences like No Fluff Just Stuff, RailsConf, and also Clojure Conj?
  Yeah, Clojure Conj, Strangeloop.
  Right now, we're just looking at the relaunch of the Clojure Koans website and I just wanted to ask, this is a teaching tool, Clojure Koans.
  It's a teaching tool for, can you describe what Clojure Koans is?
  Yeah, so the whole thing actually started, Jim Wyrick and Edge Case had put together the Ruby Coens for learning Ruby, exploring the language.
  They were really well done.
  I picked them up, just wanted to see what was going on and I really enjoyed the teaching style.
  I really like how that works.
  That style of explain something, some simple concept and show how it works is also presented in The Little Whisper and The Reason Schemer and those books.
  I really like that kind of very close one-to-one, teach a small concept and kind of evolve it.
  You're also so close to the source code, you're not in another tool and a little website or something like that.
  Yeah, and a small amount of work can be done, just kind of bend the language into a little DSL.
  Ruby and Clojure both have some great ways to do that.
  You kind of bend it to your will and make it work the way you want and you create this little learning environment.
  I tried to mimic what Jim had done with the Ruby Coens very closely because I like that style.
  Then after that, Colin Jones of 8th Light actually took, I mean he's contributed I think way more than I have at this point.
  He saw it, he embraced it and really went with it.
  The new Clojure Koans website is actually a product of 8th Light as well.
  It's written in Clojure as well.
  It is.
  The Judo framework.
  Those guys really took, they did all the work here.
  Right.
  It really wasn't me.
  I started the project and then I started the project back in 2010 at Codemesh.
  Okay, so this is actually a project at a conference.
  Yeah, so it was at Codemesh in 2010.
  A full bunch of folks had talked about the Ruby Coens.
  They were becoming popular at that point.
  We said, "Hey, what about a set of functional language Coens?" We actually started the project as a collection of Scala and F#, Clojure.
  I don't remember.
  A lot of these people participated.
  Yeah, because it was just kind of functional and we just had an umbrella.
  Yeah.
  It just kind of seems to focus down.
  So Scala forked off into their own repository over into Bitbucket and those kind of, they're much more popular there now.
  And so Colin and I talked about just making our own Clojure Koans.
  Okay.
  And that's kind of where that came from and everything kind of started there.
  Since then, it's actually forked off to its own engine and then all you do is provide the exercises.
  Oh, okay.
  And so other people have approached about doing things like the Caskalog Coens and maybe the CoreLogic Coens and those kind of things.
  It's now known like a plug-in.
  Yeah.
  There's a lining and plug-in and there's an engine you install and it actually will set up a Coens project for whatever you want.
  Oh, okay.
  And then you just add the Coens?
  Yeah.
  You just add the exercises and go.
  So it's actually this nice little modular thing now.
  And it's become kind of a nice little way to start to teach something about your project or some concept.
  But the Clojure Koans is about the language.
  No add-ons, no plug-ins.
  The way it's built is pretty simple, just using a couple of macros and some little tricks.
  Okay.
  And I'm going to jump straight from Clojure Koans to talk about some more education you've done through your book.
  Yeah.
  You co-authored with...
  Stuart Halloway.
  Yeah.
  I knew Stuart.
  I wasn't going to say Smalley.
  But you co-authored a book with him.
  What was that like coming from Clojure and being a coder and then writing a technical book?
  So technical books are...
  I think this is my first big book, right?
  I've done work for Peep Code for Jeffrey Grossenbach.
  I wrote a small book on rail security several years back.
  It was much smaller.
  So this was a bigger endeavor.
  About 300 pages, this book ended up being.
  But it was the second edition of Stu's book.
  So there was already a foundation.
  So it was much more daunting than the Peep Code book for me, but it was also less because it wasn't a blank slate.
  Right.
  And so with that, I mean, you've obviously been doing Clojure for a very long time and you've contributed to the code base.
  How much of writing the book was having to learn new stuff versus codifying things you already knew?
  I definitely learned stuff during the process of writing the book.
  A lot of it was brain dump, right?
  Right.
  So that part was nice.
  It was pretty easy.
  I was working in Clojure every day.
  I was working on the language at least one day a week, if not all week sometimes.
  And so it was nice to be able to kind of brain dump because I was right in the middle of it all.
  Right.
  And I think that makes for a good conversation.
  Did you ever have a point where you're like writing the book and then you're like, wow, when you're researching, you're like, I've been doing it wrong all along.
  And then like changed what you were, how you were, like when you were digging deep, maybe into a topic.
  I think it might've changed the way I did some things in Clojure, but not for the book.
  For the book, it was still pretty introductory.
  Yeah.
  But it was a lot easier.
  Yeah.
  It was a lot easier to write.
  It was less introductory, teaching concepts.
  And those concepts really didn't change much.
  Right.
  Between the two versions of the book, some of the, some of the code and examples changed quite a bit.
  And that was based on learning new stuff for the language and, and evolving the language, right?
  The first edition that Stuart wrote was kind of pre 1.0, right around 1.0.
  And this, this book is targeted at 1.3 and up.
  Okay.
  So the language had evolved quite a bit and between Clojure 1.0 and 1.3, there were lots of changes.
  So if somebody picks up the code, it's still relevant.
  Yeah, absolutely.
  Okay.
  Yeah.
  This is, you know, a couple of things have been released since then, but there are, this, this book is still very relevant.
  You won't find code examples broken or anything like that.
  Nothing has changed interface-wise.
  Okay.
  So the code examples would still work even if you used them with, you know, 1.4 or 1.5, as far as I know.
  Right.
  I've, I've tried some, most of them, so.
  Okay.
  And you know, just the last kind of group of questions is you've, you've gone and, and spoken at a lot of different conferences.
  Yeah.
  You've gone and, RailsConf, No Fluff Just Stuff, Clojure Conference, very different communities.
  Yes.
  Just in those three conferences.
  Yeah.
  Do you talk about different topics or do you tend to, like, have the same topic, but maybe you tailor it for that audience?
  So I talk about different stuff.
  You know, I definitely tailor it for the audience, always tailor it for the audience.
  Having a good conversation where everybody's on the same page is really important.
  You know, I think the idea of a talk is more to inspire than it is to teach.
  Right.
  Because you only have a short amount of time, right?
  Right.
  You really can't teach somebody, you can't teach a group of 100 to 1,000 people much in an hour.
  Right.
  Right.
  That's, Brian Lyle basically said the same thing.
  It's, you come out, you do a little entertainment, you share some knowledge, and then you try to get them to go and.
  Yeah.
  It, it's really about inspiring.
  It's about somebody taking away something you said that excited them and then going and researching and, and learning on their own.
  And you might have just fueled that, that, that learning.
  And that's what my, the goal of my conference talks really are, is to, to fuel exploration.
  Okay.
  And just, when you're preparing for your presentations, are, are you one of those types of people that likes to sit down and figure out, this is my script, or do you kind of just say, I know this thing, here's the general gist of what I want to talk about?
  I always write an outline.
  Okay.
  So I'll fire up Emacs in org mode and write an outline.
  And, you know, that has gotten me through lots of things.
  Okay.
  And the reason I do that is because, because the story is important.
  And when you break that down, it, it, it gets rough to follow.
  Right.
  And if you go, if you're moving really fast, because, you know, an hour's a long time, so you have to move quickly.
  If you skip a beat and go off somewhere else and don't really transition well, it's hard to follow.
  Yeah.
  You can, if you get off of too hard of a script.
  Yeah.
  So that, that outline, the outline helps make sure the story is going to go the same place from start to finish.
  And then after that, I fill in the details and slides.
  Do you ever go and do like some, some people like to, uh, kind of work the user group circuit?
  Sure.
  They do.
  Do you go in and do, uh, pre presentations at user groups to try out?
  Sometimes.
  Yes.
  Sometimes no.
  Um, it just depends on what's around, what user groups are happening.
  Um, I'll use geek fest here group on as, as a platform.
  Sometimes it happens more regularly, uh, every, every week.
  Right.
  Um, so there's more chances to hit there.
  Um, you know, you never know whether or not you're gonna be around on a certain user group night and, you know, they only have them once a month.
  So it's easier, but yeah, user groups are definitely, uh, a great place to, to test ideas.
  All right, great.
  Well, thank you very much for taking the time to step.
  Thanks.
